package main

import (
	"fmt"
	"io/ioutil"
	"net"
	"os"

	"github.com/gotoz/runq/pkg/util"
	"github.com/gotoz/runq/pkg/vm"

	"github.com/pkg/errors"
	"github.com/vishvananda/netlink"
)

func setupNetwork() ([]vm.Network, error) {
	var networks []vm.Network
	links, err := netlink.LinkList()
	if err != nil {
		return nil, errors.WithStack(err)
	}

	for _, link := range links {
		switch link.Type() {
		case "veth", "macvlan":
		default:
			continue
		}

		attr := link.Attrs()

		addrs, err := netlink.AddrList(link, netlink.FAMILY_ALL)
		if err != nil {
			return nil, errors.WithStack(err)
		}
		if len(addrs) == 0 {
			return nil, errors.Errorf("no ip found on %s", attr.Name)
		}

		var gateway net.IP
		routes, err := netlink.RouteList(link, netlink.FAMILY_V4)
		if err != nil {
			return nil, errors.WithStack(err)
		}
		for _, route := range routes {
			if route.Gw != nil {
				gateway = route.Gw
				break
			}
		}

		for _, a := range addrs {
			err = netlink.AddrDel(link, &a)
			if err != nil {
				return nil, errors.WithStack(err)
			}
		}

		if err = netlink.LinkSetDown(link); err != nil {
			return nil, errors.WithStack(err)
		}

		// create macvtap device
		mvtAttrs := netlink.NewLinkAttrs()
		mvtAttrs.Name = fmt.Sprintf("tap%s", util.RandStr(9))
		mvtAttrs.ParentIndex = attr.Index
		mvt := &netlink.Macvtap{
			Macvlan: netlink.Macvlan{
				LinkAttrs: mvtAttrs,
				Mode:      netlink.MACVLAN_MODE_BRIDGE,
			},
		}

		// On old kernels (<= 4.4) adding a Macvtap device to an interface
		// inside a network namespace can fail with "file exists".
		// Details and the required patch to fix this issue can be found here:
		// https://github.com/torvalds/linux/commit/17af2bce88d31e65ed73d638bb752d2e13c66ced
		// The work-around is to retry.
		for i := 0; i < 10000; i++ {
			err := netlink.LinkAdd(mvt)
			if err == nil || !os.IsExist(err) {
				break
			}
		}
		if err != nil {
			return networks, errors.Wrap(err, "failed to add macvtap device")
		}

		macvtap, err := netlink.LinkByName(mvtAttrs.Name)
		if err != nil {
			return nil, errors.Wrapf(err, "LinkByName %s", mvtAttrs.Name)
		}

		if err := netlink.LinkSetUp(macvtap); err != nil {
			return nil, errors.Wrapf(err, "LinkSetUp %s:", mvtAttrs.Name)
		}

		hardwareAddr := macvtap.Attrs().HardwareAddr
		if err := netlink.LinkSetHardwareAddr(link, hardwareAddr); err != nil {
			return nil, errors.Wrapf(err, "LinkSetHardwareAddr %s", hardwareAddr)
		}

		if link.Type() == "veth" {
			if err := netlink.LinkSetUp(link); err != nil {
				return nil, errors.Wrapf(err, "LinkSetUp %s", attr.Name)
			}
		}

		networks = append(networks, vm.Network{
			Name:       attr.Name,
			MvtName:    mvtAttrs.Name,
			MvtIndex:   macvtap.Attrs().Index,
			MacAddress: hardwareAddr.String(),
			MTU:        attr.MTU,
			Addrs:      addrs,
			Gateway:    gateway,
		})
	}

	return networks, nil
}

func setupDNS(dns []string, dnsOpts, dnsSearch string) error {
	const file = "/etc/resolv.conf"

	newContent := "# Generated by RunQ\n"
	if dnsOpts != "" {
		newContent += fmt.Sprintf("options %s\n", dnsOpts)
	}
	if dnsSearch != "" {
		newContent += fmt.Sprintf("search %s\n", dnsSearch)
	}
	for _, ns := range dns {
		newContent += fmt.Sprintf("nameserver %s\n", ns)
	}

	if err := ioutil.WriteFile(file, []byte(newContent), 0444); err != nil {
		return err
	}
	return os.Chmod(file, 0444)
}
